"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _lodash = require("lodash");

var _debug = _interopRequireDefault(require("../../debug"));

var _versionRanges = _interopRequireDefault(require("../../versionRanges"));

var _resolveLatestVersions = _interopRequireDefault(require("../../util/resolveLatestVersions"));

var _createManifest = require("./createManifest");

var _templates = _interopRequireDefault(require("./templates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = async (opts, context) => {
  const {
    output,
    cliRoot
  } = context;

  const templatesDir = _path.default.join(cliRoot, 'templates');

  const sourceDir = _path.default.join(templatesDir, opts.template);

  const outputDir = opts.outputDir; // Check that we have a template info file (dependencies, plugins etc)

  const template = _templates.default[opts.template];

  if (!template) {
    throw new Error(`Template "${opts.template}" not defined`);
  } // Copy template files


  (0, _debug.default)('Copying files from template "%s" to "%s"', opts.template, outputDir);
  let spinner = output.spinner('Bootstrapping files from template').start();
  await _fsExtra.default.copy(sourceDir, outputDir, {
    overwrite: false,
    errorOnExist: true
  });
  spinner.succeed(); // Merge global and template-specific plugins and dependencies

  const allModules = Object.assign({}, _versionRanges.default.core, template.dependencies || {});
  const modules = (0, _lodash.union)(Object.keys(_versionRanges.default.core), Object.keys(template.dependencies || {})); // Resolve latest versions of Sanity-dependencies

  spinner = output.spinner('Resolving latest module versions').start();
  const firstParty = modules.filter(isFirstParty);
  const thirdParty = (0, _lodash.difference)(modules, firstParty);
  const firstPartyVersions = await (0, _resolveLatestVersions.default)(firstParty, {
    asRange: true
  });
  const thirdPartyVersions = thirdParty.reduce((acc, dep) => {
    acc[dep] = allModules[dep];
    return acc;
  }, {});
  const dependencies = Object.assign({}, firstPartyVersions, thirdPartyVersions);
  spinner.succeed(); // Now create a package manifest (`package.json`) with the merged dependencies

  spinner = output.spinner('Creating default project files').start();
  const packageManifest = await (0, _createManifest.createPackageManifest)({ ...opts,
    dependencies
  }); // ...and a `sanity.json` manifest

  const baseSanityManifest = await (0, _createManifest.createSanityManifest)(opts, {
    serialize: false
  });
  const sanityManifest = template.generateSanityManifest ? template.generateSanityManifest(baseSanityManifest, opts) : baseSanityManifest; // Write non-template files to disc

  await Promise.all([writeFileIfNotExists('sanity.json', `${JSON.stringify(sanityManifest, null, 2)}\n`), writeFileIfNotExists('package.json', packageManifest)]); // Finish up by providing init process with template-specific info

  spinner.succeed();
  return template;

  async function writeFileIfNotExists(fileName, content) {
    const filePath = _path.default.join(outputDir, fileName);

    try {
      await _fsExtra.default.writeFile(filePath, content, {
        flag: 'wx'
      });
    } catch (err) {
      if (err.code === 'EEXIST') {
        output.print(`\n[WARN] File "${filePath}" already exists, skipping`);
      } else {
        throw err;
      }
    }
  }
};

exports.default = _default;

function isFirstParty(pkg) {
  return pkg.indexOf('@sanity/') === 0;
}
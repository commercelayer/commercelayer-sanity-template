"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCliRunner = getCliRunner;
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _yarnWithProgress = _interopRequireDefault(require("./actions/yarn/yarnWithProgress"));

var _lodash = require("lodash");

var _safeJson = require("@sanity/util/lib/safeJson");

var _util = require("@sanity/util");

var _cliPrompter = _interopRequireDefault(require("./prompters/cliPrompter"));

var _cliOutputter = _interopRequireDefault(require("./outputters/cliOutputter"));

var _clientWrapper = _interopRequireDefault(require("./util/clientWrapper"));

var _noSuchCommandText = _interopRequireDefault(require("./util/noSuchCommandText"));

var _commands = _interopRequireDefault(require("./commands"));

var _debug = _interopRequireDefault(require("./debug"));

var _generateCommandsDocumentation = require("./util/generateCommandsDocumentation");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-process-env */
const sanityEnv = process.env.SANITY_INTERNAL_ENV;
const environment = sanityEnv ? sanityEnv : process.env.NODE_ENV;
/* eslint-enable no-process-env */

const cmdHasName = cmdName => {
  return cmd => cmd.name === cmdName;
};

const cmdByGroup = cmd => cmd.group || 'default';

class CommandRunner {
  constructor(handlers = {}, commands = _commands.default) {
    this.handlers = handlers;
    this.commands = (0, _lodash.sortBy)(commands, 'name');
    this.commandGroups = (0, _lodash.groupBy)(this.commands, cmdByGroup);

    if (!handlers.outputter || !handlers.prompter) {
      throw new Error('`prompter` and `outputter` handlers must be defined');
    }
  }

  async runCommand(commandOrGroup, args, options) {
    if (!commandOrGroup) {
      this.handlers.outputter.print((0, _generateCommandsDocumentation.generateCommandsDocumentation)(this.commandGroups));
      return Promise.resolve();
    } // We might modify arguments for easier parsing in subcommand


    const cmdArgs = (0, _lodash.cloneDeep)(args);
    const subCommandName = args.argsWithoutOptions[0];
    const commandInfo = this.resolveCommand(commandOrGroup, subCommandName);

    if (!commandInfo) {
      throw new Error((0, _noSuchCommandText.default)(commandOrGroup, subCommandName, this.commandGroups));
    }

    const command = commandInfo.command;

    if (command.group && command.group !== 'default') {
      cmdArgs.argsWithoutOptions = args.argsWithoutOptions.slice(1);
    }

    const output = this.handlers.outputter;
    const {
      prompt
    } = this.handlers.prompter;

    const manifestPath = _path.default.join(options.workDir, 'sanity.json');

    (0, _debug.default)(`Reading "${manifestPath}"`);
    const baseManifest = await (0, _safeJson.loadJson)(manifestPath);
    const manifest = (0, _util.reduceConfig)(baseManifest || {}, environment, {
      studioRootPath: options.workDir
    });
    const apiClient = (0, _clientWrapper.default)(manifest, manifestPath);
    const context = {
      output,
      prompt,
      apiClient,
      yarn: _yarnWithProgress.default,
      chalk: _chalk.default,
      ...options,
      commandRunner: this
    };

    if (command.isGroupRoot) {
      return context.output.print((0, _generateCommandsDocumentation.generateCommandsDocumentation)(this.commandGroups, command.name));
    }

    if (typeof command.action !== 'function') {
      const cmdName = command.name || commandOrGroup || '<unknown>';
      (0, _debug.default)(`Command "${cmdName}" doesnt have a valid "action"-property, showing help`);
      const groupName = command.group && command.group !== 'default' ? command.group : null;
      return context.output.print((0, _generateCommandsDocumentation.generateCommandDocumentation)(command, groupName, subCommandName));
    }

    (0, _debug.default)(`Running command "${command.name}"`);
    return command.action(cmdArgs, context);
  }

  resolveCommand(commandOrGroup, subCommandName) {
    // First, see if there is a group with the given name
    if (this.commandGroups[commandOrGroup] && subCommandName) {
      (0, _debug.default)(`Found group for name "${commandOrGroup}", resolving subcommand`);
      const subCommand = this.resolveSubcommand(this.commandGroups[commandOrGroup], subCommandName, commandOrGroup);
      (0, _debug.default)(subCommand ? `Subcommand resolved to "${subCommand.commandName}"` : `Subcommand with name "${subCommandName}" not found`);
      return subCommand;
    } // No group? See if there's a command within the default group


    (0, _debug.default)(`No group found with name "${commandOrGroup}", looking for command`);
    const command = this.commandGroups.default.find(cmdHasName(commandOrGroup));

    if (command) {
      (0, _debug.default)(`Found command in default group with name "${commandOrGroup}"`);
      return {
        command: command,
        commandName: command.name,
        parentName: 'default',
        isGroup: command.isGroupRoot || false,
        isCommand: true
      };
    }

    (0, _debug.default)(`No default command with name "${commandOrGroup}" found, giving up`);
    return null;
  }

  resolveSubcommand(group, subCommandName, parentGroupName) {
    if (!subCommandName) {
      return null;
    }

    const subCommand = group.find(cmdHasName(subCommandName));

    if (!subCommand) {
      throw new Error((0, _noSuchCommandText.default)(subCommandName, parentGroupName, this.commandGroups));
    }

    return {
      command: subCommand,
      commandName: subCommandName,
      parentName: parentGroupName,
      isGroup: false,
      isCommand: true
    };
  }

  resolveHelpForGroup(groupName) {
    return {
      command: this.commandGroups.default.find(cmdHasName('help')),
      commandName: 'help',
      isGroup: false,
      isCommand: true
    };
  }

}

exports.default = CommandRunner;

function getCliRunner(...args) {
  return new CommandRunner({
    outputter: _cliOutputter.default,
    prompter: _cliPrompter.default
  }, ...args);
}